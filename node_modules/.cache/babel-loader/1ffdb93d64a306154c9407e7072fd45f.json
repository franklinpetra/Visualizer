{"ast":null,"code":"// export function getBubbleSortAnimations(array){\n//     const animations = [];\n//     if (array.length <= 1) return array;\n//     const auxiliaryArray = array.slice();\n//     bubbleSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n//     return animations;\n// }\n//     function bubbleSortHelper(\n//     mainArray,\n//     startIdx,\n//     endIdx,\n//     auxiliaryArray,\n//     animations,\n//     ) {\n//     if (startIdx === endIdx) return;\n//     const middleIdx = Math.floor((startIdx + endIdx) / 2);\n//     bubbleSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n//     bubbleSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n//     doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n//     }\n//     function doMerge(\n//         mainArray,\n//         startIdx,\n//         middleIdx,\n//         endIdx,\n//         auxiliaryArray,\n//         animations,\n//         ) {\n//         let k = startIdx;\n//         let i = startIdx;\n//         let j = middleIdx + 1;\n//         while (i <= middleIdx && j <= endIdx) {\n//         // These are the values being Compared; we push them once\n//         // to change their color.\n//         animations.push([i, j]);\n//         // These are the values that we're comparing; we push them a second\n//         // time to revert their color.\n//         animations.push([i, j]);\n//         if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n//             // We overwrite the value at index k in the original array with the\n//             // value at index i in the auxiliary array.\n//             animations.push([k, auxiliaryArray[i]]);\n//             mainArray[k++] = auxiliaryArray[i++];\n//         }   \n//             else {\n//             // We overwrite the value at index k in the original array with the\n//             // value at index j in the auxiliary array.\n//             animations.push([k, auxiliaryArray[j]]);\n//             mainArray[k++] = auxiliaryArray[j++];\n//         }\n//         }\n//     while (i <= middleIdx) {\n//     // These are the values that we're comparing; we push them once\n//     // to change their color.\n//     animations.push([i, i]);\n//     // These are the values that we're comparing; we push them a second\n//     // time to revert their color.\n//     animations.push([i, i]);\n//     // We overwrite the value at index k in the original array with the\n//     // value at index i in the auxiliary array.\n//     animations.push([k, auxiliaryArray[i]]);\n//     mainArray[k++] = auxiliaryArray[i++];\n//     }\n//     while (j <= endIdx) {\n//     // These are the values that being compared; we push them once\n//     // to change their color.\n//     animations.push([j, j]);\n//     // These are the values that being compared; we push them a second\n//     // time to revert their color.\n//     animations.push([j, j]);\n//     // We overwrite the value at index k in the original array with the\n//     // value at index j in the auxiliary array.\n//     animations.push([k, auxiliaryArray[j]]);\n//     mainArray[k++] = auxiliaryArray[j++];\n//     }\n// }\n// // bubbleSort(array) {\n// //     const animations = [];\n// //     let end = arr.length -1;\n// //     if ( array.length <= 1) return array;\n// //     const auxiliaryArray = swapped = false;\n// //         for(let i=0, j=1; i < end; i++, j++){\n// //             if (arr[i] > arr[j]){\n// //             swapped = true;\n// //             [arr[i], arr[j]] = [arr[j], arr[i]];\n// //             }\n// //         }\n// //         end --;\n// //     }\n// //     do {\n// //         bubbleSort(unsortedArr);\n// //     } \n// //     while (swapped); \n// // from James Gosling who created it to be animated visually and uses a sortAlgorithm as the parent:\n// // class BubbleSortAlgorithm extends SortAlgorithm {\n// //     void sort(int a[]) throws Exception {\n// // \tfor (int i = a.length; --i>=0; )\n// // \t    for (int j = 0; j<i; j++) {\n// // \t\tif (stopRequested) {\n// // \t\t    return;\n// // \t\t}\n// // \t\tif (a[j] > a[j+1]) {\n// // \t\t    int T = a[j];\n// // \t\t    a[j] = a[j+1];\n// // \t\t    a[j+1] = T;\n// // \t\t}\n// // \t\tpause(i,j);\n// // \t    }\n// // \tpause(-1,-1);\n// //     }\n// // }","map":{"version":3,"sources":["/Users/petrafranklin/Coding_DoJo/mern/Assignments/algo_visualizer/src/Components/bubbleSort.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// export function getBubbleSortAnimations(array){\n//     const animations = [];\n//     if (array.length <= 1) return array;\n//     const auxiliaryArray = array.slice();\n//     bubbleSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n//     return animations;\n    \n// }\n//     function bubbleSortHelper(\n//     mainArray,\n//     startIdx,\n//     endIdx,\n//     auxiliaryArray,\n//     animations,\n//     ) {\n//     if (startIdx === endIdx) return;\n//     const middleIdx = Math.floor((startIdx + endIdx) / 2);\n//     bubbleSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n//     bubbleSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n//     doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n//     }\n\n//     function doMerge(\n//         mainArray,\n//         startIdx,\n//         middleIdx,\n//         endIdx,\n//         auxiliaryArray,\n//         animations,\n//         ) {\n//         let k = startIdx;\n//         let i = startIdx;\n//         let j = middleIdx + 1;\n//         while (i <= middleIdx && j <= endIdx) {\n\n//         // These are the values being Compared; we push them once\n//         // to change their color.\n//         animations.push([i, j]);\n//         // These are the values that we're comparing; we push them a second\n//         // time to revert their color.\n//         animations.push([i, j]);\n//         if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n//             // We overwrite the value at index k in the original array with the\n//             // value at index i in the auxiliary array.\n//             animations.push([k, auxiliaryArray[i]]);\n//             mainArray[k++] = auxiliaryArray[i++];\n//         }   \n//             else {\n//             // We overwrite the value at index k in the original array with the\n//             // value at index j in the auxiliary array.\n//             animations.push([k, auxiliaryArray[j]]);\n//             mainArray[k++] = auxiliaryArray[j++];\n//         }\n//         }\n\n//     while (i <= middleIdx) {\n//     // These are the values that we're comparing; we push them once\n//     // to change their color.\n//     animations.push([i, i]);\n//     // These are the values that we're comparing; we push them a second\n//     // time to revert their color.\n//     animations.push([i, i]);\n//     // We overwrite the value at index k in the original array with the\n//     // value at index i in the auxiliary array.\n//     animations.push([k, auxiliaryArray[i]]);\n//     mainArray[k++] = auxiliaryArray[i++];\n//     }\n//     while (j <= endIdx) {\n//     // These are the values that being compared; we push them once\n//     // to change their color.\n//     animations.push([j, j]);\n//     // These are the values that being compared; we push them a second\n//     // time to revert their color.\n//     animations.push([j, j]);\n//     // We overwrite the value at index k in the original array with the\n//     // value at index j in the auxiliary array.\n//     animations.push([k, auxiliaryArray[j]]);\n//     mainArray[k++] = auxiliaryArray[j++];\n//     }\n\n// }\n\n\n// // bubbleSort(array) {\n// //     const animations = [];\n// //     let end = arr.length -1;\n    \n// //     if ( array.length <= 1) return array;\n// //     const auxiliaryArray = swapped = false;\n// //         for(let i=0, j=1; i < end; i++, j++){\n// //             if (arr[i] > arr[j]){\n// //             swapped = true;\n// //             [arr[i], arr[j]] = [arr[j], arr[i]];\n// //             }\n// //         }\n// //         end --;\n// //     }\n// //     do {\n// //         bubbleSort(unsortedArr);\n// //     } \n// //     while (swapped); \n\n\n// // from James Gosling who created it to be animated visually and uses a sortAlgorithm as the parent:\n// // class BubbleSortAlgorithm extends SortAlgorithm {\n// //     void sort(int a[]) throws Exception {\n// // \tfor (int i = a.length; --i>=0; )\n// // \t    for (int j = 0; j<i; j++) {\n// // \t\tif (stopRequested) {\n// // \t\t    return;\n// // \t\t}\n// // \t\tif (a[j] > a[j+1]) {\n// // \t\t    int T = a[j];\n// // \t\t    a[j] = a[j+1];\n// // \t\t    a[j+1] = T;\n// // \t\t}\n// // \t\tpause(i,j);\n// // \t    }\n// // \tpause(-1,-1);\n// //     }\n// // }"]},"metadata":{},"sourceType":"module"}