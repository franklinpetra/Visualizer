{"ast":null,"code":"// import { ReactComponent } from \"*.svg\";\n// export function getQuickSortAnimations(array) {\n//   const animations = [];\n//   if (array.length <= 1) return array;\n//   const auxiliaryArray = array.slice();\n//   quickSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n//   return animations;\n//   }\n//   function quickSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, animations) {\n//     if (startIdx === endIdx) return;\n//     const middleIdx = Math.floor((startIdx + endIdx) / 2);\n//     quickSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n//     quickSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n//     doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n//     }\n//   function doMerge(\n//       mainArray,\n//       startIdx,\n//       middleIdx,\n//       endIdx,\n//       auxiliaryArray,\n//       animations,\n//       ) {\n//       let k = startIdx;\n//       let i = startIdx;\n//       let j = middleIdx + 1;\n//       while (i <= middleIdx && j <= endIdx) {\n// let values = [];\n// let w = 5;\n// let states = [];\n// function setup(){\n//   createCanvas(windowWidth, windowHeight);\n//   values = newArray (floor(width/ w));\n//   for(let i = 0; i < values.length;I++){\n//     values [i] = random(height);\n//     states[i] = -1;\n//   }\n//   quickSort(values, 0, values.length -1);\n// }   \n// async function quickSort(mainArray, startIdx, endIdx) {\n// \tif (start>= end) { \n//     return; \n//   } \n//   let index = await partition(mainArray, startIdx, endIdx);\n//   states[index] = -1;\n//   await Promise.all([\n//     quickSort (mainArray, start, index-1),\n//     quickSort(mainArray, index + 1, endIdx)\n//   ]);\n// }\n// async function partition(mainArray, startIdx, endIdx){\n//   for (let i = startIdx; i < endIdx;i++) {\n//     states[i] = 1;\n//   }\n//   let pivotValue = mainArray[endIdx];\n//   let pivotIndex = startIdx;\n//   states[pivotIndex] = 0;\n//   for(let i = startIdx; i < endIdx; i++) {\n//     if (mainArray[i] < pivotValue){\n//       await swap(mainArr, i, pivotIndex);\n//       states[pivotIndex] = -1;\n//       pivotIndex++;\n//       states[pivotIndex] = 0;\n//     }\n//   } \n//   await swap(mainArray, pivotIndex, endIdx);\n//   for (let i = startIdx; i < endIdx;i++) {\n//     if (i != pivotIndex){\n//     states[i] = 1;\n//     }\n//   }\n//   return pivotIndex;\n// }\n// function draw() {\n//   background(51);\n//   for (let i=0;i<values.length; i++) {\n//     noStroke();\n//     if (states[i] == 0) {\n//       fill ('#E0777D');\n//     } \n//       else if (states[i] == 1) {\n//         fill ('#D6FFB7');\n//       } \n//       else {\n//       fill(255);\n//       }\n//     rect(i * w, height - values[i], w, values[i]);\n//   }\n// }\n//   async function Swap(mainArray, a, b) {\n//     await sleep(50);\n//     let temp = arr[a];\n//     arr[a]= arr[b];\n//     arr[b] = temp;\n//   }\n//   function sleep(ms){\n//     return new Promise(resolve => setTimeout(resolve, ms));\n//   }\n// \t\tvar left = [];\n// \t\tvar right = [];\n// \t\tvar newArray = [];\n// \t\tvar pivot = mainArray.pop();\n// \t\tvar length = mainArray.length;\n// \t\tfor (var i = 0; i < length; i++) {\n// \t\t\tif (mainArray[i] <= pivot) {\n// \t\t\t\tleft.push(mainArray[i]);\n// \t\t\t} else {\n// \t\t\t\tright.push(mainArray[i]);\n// \t\t\t}\n// \t\t}\n// \t\treturn newArray.concat(quickSort(left), pivot, quickSort(right));\n// var myArray = [3, 0, 2, 5, -1, 4, 1 ];\n// console.log(\"Original array: \" + myArray);\n// var sortedArray = quick_Sort(myArray);\n// console.log(\"Sorted array: \" + sortedArray);\n//an example from from James Gosling that was created to become animated.:\n// class QSortAlgorithm extends SortAlgorithm {\n//   void sort(int a[], int lo0, int hi0) throws Exception {\n// int lo = lo0;\n// int hi = hi0;\n// pause(lo, hi);\n// if (lo >= hi) {\n//     return;\n// }\n// int mid = a[(lo + hi) / 2];\n// while (lo < hi) {\n//     while (lo<hi && a[lo] < mid) {\n//   lo++;\n//     }\n//     while (lo<hi && a[hi] > mid) {\n//   hi--;\n//     }\n//     if (lo < hi) {\n//   int T = a[lo];\n//   a[lo] = a[hi];\n//   a[hi] = T;\n//   pause();\n//     }\n// }\n// if (hi < lo) {\n//     int T = hi;\n//     hi = lo;\n//     lo = T;\n// }\n// sort(a, lo0, lo);\n// sort(a, lo == lo0 ? lo+1 : lo, hi0);\n//   }\n//   void sort(int a[]) throws Exception {\n// sort(a, 0, a.length-1);\n// pause(-1,-1);\n//   }\n// }","map":{"version":3,"sources":["/Users/petrafranklin/Coding_DoJo/mern/Assignments/algo_visualizer/src/Algorithms/quickSort.js"],"names":[],"mappings":"AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA","sourcesContent":["\n\n\n// import { ReactComponent } from \"*.svg\";\n\n// export function getQuickSortAnimations(array) {\n//   const animations = [];\n//   if (array.length <= 1) return array;\n//   const auxiliaryArray = array.slice();\n//   quickSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n//   return animations;\n//   }\n\n//   function quickSortHelper(mainArray, startIdx, endIdx, auxiliaryArray, animations) {\n//     if (startIdx === endIdx) return;\n//     const middleIdx = Math.floor((startIdx + endIdx) / 2);\n//     quickSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n//     quickSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n//     doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n//     }\n\n//   function doMerge(\n//       mainArray,\n//       startIdx,\n//       middleIdx,\n//       endIdx,\n//       auxiliaryArray,\n//       animations,\n//       ) {\n//       let k = startIdx;\n//       let i = startIdx;\n//       let j = middleIdx + 1;\n//       while (i <= middleIdx && j <= endIdx) {\n\n\n// let values = [];\n// let w = 5;\n// let states = [];\n\n// function setup(){\n//   createCanvas(windowWidth, windowHeight);\n//   values = newArray (floor(width/ w));\n//   for(let i = 0; i < values.length;I++){\n//     values [i] = random(height);\n//     states[i] = -1;\n//   }\n//   quickSort(values, 0, values.length -1);\n// }   \n\n\n// async function quickSort(mainArray, startIdx, endIdx) {\n// \tif (start>= end) { \n//     return; \n//   } \n//   let index = await partition(mainArray, startIdx, endIdx);\n//   states[index] = -1;\n\n//   await Promise.all([\n//     quickSort (mainArray, start, index-1),\n//     quickSort(mainArray, index + 1, endIdx)\n//   ]);\n// }\n\n\n// async function partition(mainArray, startIdx, endIdx){\n\n//   for (let i = startIdx; i < endIdx;i++) {\n//     states[i] = 1;\n//   }\n\n//   let pivotValue = mainArray[endIdx];\n//   let pivotIndex = startIdx;\n//   states[pivotIndex] = 0;\n//   for(let i = startIdx; i < endIdx; i++) {\n//     if (mainArray[i] < pivotValue){\n//       await swap(mainArr, i, pivotIndex);\n//       states[pivotIndex] = -1;\n//       pivotIndex++;\n//       states[pivotIndex] = 0;\n//     }\n//   } \n//   await swap(mainArray, pivotIndex, endIdx);\n\n//   for (let i = startIdx; i < endIdx;i++) {\n//     if (i != pivotIndex){\n//     states[i] = 1;\n//     }\n//   }\n//   return pivotIndex;\n// }\n\n// function draw() {\n//   background(51);\n\n//   for (let i=0;i<values.length; i++) {\n//     noStroke();\n//     if (states[i] == 0) {\n//       fill ('#E0777D');\n//     } \n//       else if (states[i] == 1) {\n//         fill ('#D6FFB7');\n//       } \n//       else {\n//       fill(255);\n//       }\n//     rect(i * w, height - values[i], w, values[i]);\n//   }\n// }\n\n//   async function Swap(mainArray, a, b) {\n//     await sleep(50);\n//     let temp = arr[a];\n//     arr[a]= arr[b];\n//     arr[b] = temp;\n//   }\n\n//   function sleep(ms){\n//     return new Promise(resolve => setTimeout(resolve, ms));\n//   }\n\n\n// \t\tvar left = [];\n// \t\tvar right = [];\n// \t\tvar newArray = [];\n// \t\tvar pivot = mainArray.pop();\n// \t\tvar length = mainArray.length;\n\n// \t\tfor (var i = 0; i < length; i++) {\n// \t\t\tif (mainArray[i] <= pivot) {\n// \t\t\t\tleft.push(mainArray[i]);\n// \t\t\t} else {\n// \t\t\t\tright.push(mainArray[i]);\n// \t\t\t}\n// \t\t}\n\n// \t\treturn newArray.concat(quickSort(left), pivot, quickSort(right));\n\n\n// var myArray = [3, 0, 2, 5, -1, 4, 1 ];\n\n// console.log(\"Original array: \" + myArray);\n// var sortedArray = quick_Sort(myArray);\n// console.log(\"Sorted array: \" + sortedArray);\n\n\n//an example from from James Gosling that was created to become animated.:\n// class QSortAlgorithm extends SortAlgorithm {\n//   void sort(int a[], int lo0, int hi0) throws Exception {\n// int lo = lo0;\n// int hi = hi0;\n// pause(lo, hi);\n// if (lo >= hi) {\n//     return;\n// }\n// int mid = a[(lo + hi) / 2];\n// while (lo < hi) {\n//     while (lo<hi && a[lo] < mid) {\n//   lo++;\n//     }\n//     while (lo<hi && a[hi] > mid) {\n//   hi--;\n//     }\n//     if (lo < hi) {\n//   int T = a[lo];\n//   a[lo] = a[hi];\n//   a[hi] = T;\n//   pause();\n//     }\n// }\n// if (hi < lo) {\n//     int T = hi;\n//     hi = lo;\n//     lo = T;\n// }\n// sort(a, lo0, lo);\n// sort(a, lo == lo0 ? lo+1 : lo, hi0);\n//   }\n\n//   void sort(int a[]) throws Exception {\n// sort(a, 0, a.length-1);\n// pause(-1,-1);\n//   }\n// }"]},"metadata":{},"sourceType":"module"}